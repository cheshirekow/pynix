// Copyright 2020 Josh Bialkowski <josh.bialkowski@gmail.com>

#include "pynix/docstr.h"

const char* g_chroot_docstr = 
"\n"
"chroot() changes the root directory of the calling process to that\n"
"specified in path.  This directory will be used for pathnames\n"
"beginning with /.  The root directory is inherited by all children of\n"
"the calling process.\n"
"\n"
"Only a privileged process (Linux: one with the CAP_SYS_CHROOT\n"
"capability in its user namespace) may call chroot().\n"
"\n"
"This call changes an ingredient in the pathname resolution process\n"
"and does nothing else.  In particular, it is not intended to be used\n"
"for any kind of security purpose, neither to fully sandbox a process\n"
"nor to restrict filesystem system calls.  In the past, chroot() has\n"
"been used by daemons to restrict themselves prior to passing paths\n"
"supplied by untrusted users to system calls such as open(2).\n"
"However, if a folder is moved out of the chroot directory, an\n"
"attacker can exploit that to get out of the chroot directory as well.\n"
"The easiest way to do that is to chdir(2) to the to-be-moved\n"
"directory, wait for it to be moved out, then open a path like\n"
"../../../etc/passwd.\n"
"\n"
"A slightly trickier variation also works under some circumstances if\n"
"chdir(2) is not permitted.  If a daemon allows a \"chroot directory\\n"
"to be specified, that usually means that if you want to prevent\n"
"remote users from accessing files outside the chroot directory, you\n"
"must ensure that folders are never moved out of it.\n"
"\n"
"This call does not change the current working directory, so that\n"
"after the call '.' can be outside the tree rooted at '/'.  In\n"
"particular, the superuser can escape from a \"chroot jail\" by doing:\n"
"\n"
"    mkdir foo; chroot foo; cd ..\n"
"\n"
"This call does not close open file descriptors, and such file\n"
"descriptors may allow access to files outside the chroot tree.\n"
"\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/chroot.2.html\n"
"\n"
;

const char* g_epoll_create_docstr = 
"\n"
"epoll_create() creates a new epoll(7) instance.  Since Linux 2.6.8,\n"
"the size argument is ignored, but must be greater than zero; see\n"
"NOTES.\n"
"\n"
"epoll_create() returns a file descriptor referring to the new epoll\n"
"instance.  This file descriptor is used for all the subsequent calls\n"
"to the epoll interface.  When no longer required, the file descriptor\n"
"returned by epoll_create() should be closed by using close(2).  When\n"
"all file descriptors referring to an epoll instance have been closed,\n"
"the kernel destroys the instance and releases the associated\n"
"resources for reuse.\n"
"\n"
"epoll_create1()\n"
"    If flags is 0, then, other than the fact that the obsolete size\n"
"    argument is dropped, epoll_create1() is the same as epoll_create().\n"
"    The following value can be included in flags to obtain different\n"
"    behavior:\n"
"\n"
"    EPOLL_CLOEXEC\n"
"          Set the close-on-exec (FD_CLOEXEC) flag on the new file\n"
"          descriptor.  See the description of the O_CLOEXEC flag in\n"
"          open(2) for reasons why this may be useful.\n"
"\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/epoll_create.2.html\n"
"\n"
;

const char* g_epoll_ctl_docstr = 
"\n"
"int epoll_ctl(int epfd, int op, int fd, uint32_t events, PyObject* data);\n"
"\n"
"This system call is used to add, modify, or remove entries in the\n"
"interest list of the epoll(7) instance referred to by the file\n"
"descriptor epfd.  It requests that the operation op be performed for\n"
"the target file descriptor, fd.\n"
"\n"
"Valid values for the op argument are:\n"
"\n"
"EPOLL_CTL_ADD\n"
"      Add an entry to the interest list of the epoll file\n"
"      descriptor, epfd.  The entry includes the file descriptor, fd,\n"
"      a reference to the corresponding open file description (see\n"
"      epoll(7) and open(2)), and the settings specified in event.\n"
"\n"
"EPOLL_CTL_MOD\n"
"      Change the settings associated with fd in the interest list to\n"
"      the new settings specified in event.\n"
"\n"
"EPOLL_CTL_DEL\n"
"      Remove (deregister) the target file descriptor fd from the\n"
"      interest list.  The event argument is ignored and can be NULL\n"
"      (but see BUGS below).\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/epoll_ctl.2.html\n"
"\n"
"NOTE: If you provide a data object, it will be associated with the epoll\n"
"file descriptor and returned on events, but it's reference count will not be\n"
"incremented. You will need to hold your own reference.\n"
"\n"
;

const char* g_epoll_pwait_docstr = 
"\n"
"int epoll_pwait(\n"
"  int epfd, pynix.EpollEventBuf buf, int timeout, pynix.SigSet sigset);\n"
"\n"
"The relationship between epoll_wait() and epoll_pwait() is analogous\n"
"to the relationship between select(2) and pselect(2): like\n"
"pselect(2), epoll_pwait() allows an application to safely wait until\n"
"either a file descriptor becomes ready or until a signal is caught.\n"
"\n"
"The following epoll_pwait() call:\n"
"\n"
"    ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"
"\n"
"is equivalent to atomically executing the following calls:\n"
"\n"
"    sigset_t origmask;\n"
"\n"
"    pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"    pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
"\n"
"The sigmask argument may be specified as NULL, in which case\n"
"epoll_pwait() is equivalent to epoll_wait().\n"
"\n"
;

const char* g_epoll_wait_docstr = 
"\n"
"int epoll_wait(int epfd, pynix.EpollEventBuf* buf, int timeout);\n"
"\n"
"The epoll_wait() system call waits for events on the epoll(7)\n"
"instance referred to by the file descriptor epfd.  The buffer pointed\n"
"to by events is used to return information from the ready list about\n"
"file descriptors in the interest list that have some events\n"
"available.  Up to maxevents are returned by epoll_wait().  The\n"
"maxevents argument must be greater than zero.\n"
"\n"
"The timeout argument specifies the number of milliseconds that\n"
"epoll_wait() will block.  Time is measured against the\n"
"CLOCK_MONOTONIC clock.\n"
"\n"
"A call to epoll_wait() will block until either:\n"
"\n"
"* a file descriptor delivers an event;\n"
"* the call is interrupted by a signal handler; or\n"
"* the timeout expires.\n"
"\n"
"Note that the timeout interval will be rounded up to the system clock\n"
"granularity, and kernel scheduling delays mean that the blocking\n"
"interval may overrun by a small amount.  Specifying a timeout of -1\n"
"causes epoll_wait() to block indefinitely, while specifying a timeout\n"
"equal to zero cause epoll_wait() to return immediately, even if no\n"
"events are available.\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/epoll_wait.2.html\n"
"\n"
"NOTE: If you provide a data object, it will be associated with the epoll\n"
"file descriptor and returned on events, but it's reference count will not be\n"
"incremented. You will need to hold your own reference.\n"
"\n"
;

const char* g_getresuid_docstr = 
"\n"
"getresuid() returns the real UID, the effective UID, and the saved\n"
"set-user-ID of the calling process, in the arguments ruid, euid, and\n"
"suid, respectively.  getresgid() performs the analogous task for the\n"
"process's group IDs.\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/getresuid.2.html\n"
"\n"
;

const char* g_gettid_docstr = 
"\n"
"gettid() returns the caller's thread ID (TID).  In a single-threaded\n"
"process, the thread ID is equal to the process ID (PID, as returned\n"
"by getpid(2)).  In a multithreaded process, all threads have the same\n"
"PID, but each one has a unique TID.  For further details, see the\n"
"discussion of CLONE_THREAD in clone(2).\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/gettid.2.html\n"
"\n"
"\n"
"\n"
;

const char* g_inotify_add_watch_docstr = 
"\n"
"inotify_add_watch() adds a new watch, or modifies an existing watch,\n"
"for the file whose location is specified in pathname; the caller must\n"
"have read permission for this file.  The fd argument is a file\n"
"descriptor referring to the inotify instance whose watch list is to\n"
"be modified.  The events to be monitored for pathname are specified\n"
"in the mask bit-mask argument.  See inotify(7) for a description of\n"
"the bits that can be set in mask.\n"
"\n"
"A successful call to inotify_add_watch() returns a unique watch\n"
"descriptor for this inotify instance, for the filesystem object\n"
"(inode) that corresponds to pathname.  If the filesystem object was\n"
"not previously being watched by this inotify instance, then the watch\n"
"descriptor is newly allocated.  If the filesystem object was already\n"
"being watched (perhaps via a different link to the same object), then\n"
"the descriptor for the existing watch is returned.\n"
"\n"
"The watch descriptor is returned by later read(2)s from the inotify\n"
"file descriptor.  These reads fetch inotify_event structures (see\n"
"inotify(7)) indicating filesystem events; the watch descriptor inside\n"
"this structure identifies the object for which the event occurred.\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/inotify_add_watch.2.html\n"
"\n"
;

const char* g_inotify_init_docstr = 
"\n"
"inotify_init() initializes a new inotify instance and returns a file\n"
"descriptor associated with a new inotify event queue.\n"
"\n"
"If flags is 0, then inotify_init1() is the same as inotify_init().\n"
"The following values can be bitwise ORed in flags to obtain different\n"
"behavior:\n"
"\n"
"IN_NONBLOCK\n"
"      Set the O_NONBLOCK file status flag on the open file\n"
"      description (see open(2)) referred to by the new file\n"
"      descriptor.  Using this flag saves extra calls to fcntl(2) to\n"
"      achieve the same result.\n"
"\n"
"IN_CLOEXEC\n"
"      Set the close-on-exec (FD_CLOEXEC) flag on the new file\n"
"      descriptor.  See the description of the O_CLOEXEC flag in\n"
"      open(2) for reasons why this may be useful.\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/inotify_init.2.html\n"
"\n"
"\n"
;

const char* g_inotify_read_docstr = 
"\n"
"To determine what events have occurred, an application read(2)s from\n"
"the inotify file descriptor.  If no events have so far occurred,\n"
"then, assuming a blocking file descriptor, read(2) will block until\n"
"at least one event occurs (unless interrupted by a signal, in which\n"
"case the call fails with the error EINTR; see signal(7)).\n"
"\n"
"Each successful read(2) returns a buffer containing one or more of\n"
"the following structures:\n"
"\n"
"    struct inotify_event {\n"
"        int      wd;       /* Watch descriptor */\n"
"        uint32_t mask;     /* Mask describing event */\n"
"        uint32_t cookie;   /* Unique cookie associating related\n"
"                              events (for rename(2)) */\n"
"        uint32_t len;      /* Size of name field */\n"
"        char     name[];   /* Optional null-terminated name */\n"
"    };\n"
"\n"
"wd identifies the watch for which this event occurs.  It is one of\n"
"the watch descriptors returned by a previous call to\n"
"inotify_add_watch(2).\n"
"\n"
"mask contains bits that describe the event that occurred (see below).\n"
"\n"
"cookie is a unique integer that connects related events.  Currently,\n"
"this is used only for rename events, and allows the resulting pair of\n"
"IN_MOVED_FROM and IN_MOVED_TO events to be connected by the applica\u2010\n"
"tion.  For all other event types, cookie is set to 0.\n"
"\n"
"The name field is present only when an event is returned for a file\n"
"inside a watched directory; it identifies the filename within the\n"
"watched directory.  This filename is null-terminated, and may include\n"
"further null bytes ('\\0') to align subsequent reads to a suitable\n"
"address boundary.\n"
"\n"
"The len field counts all of the bytes in name, including the null\n"
"bytes; the length of each inotify_event structure is thus\n"
"sizeof(struct inotify_event)+len.\n"
"\n"
"The behavior when the buffer given to read(2) is too small to return\n"
"information about the next event depends on the kernel version: in\n"
"kernels before 2.6.21, read(2) returns 0; since kernel 2.6.21,\n"
"read(2) fails with the error EINVAL.  Specifying a buffer of size\n"
"\n"
"    sizeof(struct inotify_event) + NAME_MAX + 1\n"
"\n"
"will be sufficient to read at least one event.\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man7/inotify.7.html\n"
"\n"
;

const char* g_inotify_rm_watch_docstr = 
"\n"
"inotify_rm_watch() removes the watch associated with the watch\n"
"descriptor wd from the inotify instance associated with the file\n"
"descriptor fd.\n"
"\n"
"Removing a watch causes an IN_IGNORED event to be generated for this\n"
"watch descriptor.  (See inotify(7).)\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/inotify_rm_watch.2.html\n"
"\n"
;

const char* g_mount_docstr = 
"\n"
"mount() attaches the filesystem specified by source (which is often a\n"
"pathname referring to a device, but can also be the pathname of a\n"
"directory or file, or a dummy string) to the location (a directory or\n"
"file) specified by the pathname in target.\n"
"\n"
"Appropriate privilege (Linux: the CAP_SYS_ADMIN capability) is\n"
"required to mount filesystems.\n"
"\n"
"Values for the filesystemtype argument supported by the kernel are\n"
"listed in /proc/filesystems (e.g., \"btrfs\", \"ext4\", \"jfs\", \"xfs\",\n"
"\"vfat\", \"fuse\", \"tmpfs\", \"cgroup\", \"proc\", \"mqueue\", \"nfs\", \"cifs\",\n"
"\"iso9660\").  Further types may become available when the appropriate\n"
"modules are loaded.\n"
"\n"
"The data argument is interpreted by the different filesystems.\n"
"Typically it is a string of comma-separated options understood by\n"
"this filesystem.  See mount(8) for details of the options available\n"
"for each filesystem type.\n"
"\n"
"A call to mount() performs one of a number of general types of\n"
"operation, depending on the bits specified in mountflags.  The choice\n"
"of which operation to perform is determined by testing the bits set\n"
"in mountflags, with the tests being conducted in the order listed\n"
"here:\n"
"\n"
"*  Remount an existing mount: mountflags includes MS_REMOUNT.\n"
"\n"
"*  Create a bind mount: mountflags includes MS_BIND.\n"
"\n"
"*  Change the propagation type of an existing mount: mountflags\n"
"  includes one of MS_SHARED, MS_PRIVATE, MS_SLAVE, or MS_UNBINDABLE.\n"
"\n"
"*  Move an existing mount to a new location: mountflags includes\n"
"  MS_MOVE.\n"
"\n"
"*  Create a new mount: mountflags includes none of the above flags.\n"
"\n"
"Each of these operations is detailed later in this page.  Further\n"
"flags may be specified in mountflags to modify the behavior of\n"
"mount(), as described below.\n"
"\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/mount.2.html\n"
"\n"
;

const char* g_prctl_docstr = 
"\n"
"prctl() is called with a first argument describing what to do (with\n"
"values defined in <linux/prctl.h>), and further arguments with a\n"
"significance depending on the first one.  The first argument can be:\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/signalfd.2.html\n"
"\n"
;

const char* g_setresuid_docstr = 
"\n"
"setresuid() sets the real user ID, the effective user ID, and the\n"
"saved set-user-ID of the calling process.\n"
"\n"
"An unprivileged process may change its real UID, effective UID, and\n"
"saved set-user-ID, each to one of: the current real UID, the current\n"
"effective UID or the current saved set-user-ID.\n"
"\n"
"A privileged process (on Linux, one having the CAP_SETUID capability)\n"
"may set its real UID, effective UID, and saved set-user-ID to\n"
"arbitrary values.\n"
"\n"
"If one of the arguments equals -1, the corresponding value is not\n"
"changed.\n"
"\n"
"Regardless of what changes are made to the real UID, effective UID,\n"
"and saved set-user-ID, the filesystem UID is always set to the same\n"
"value as the (possibly new) effective UID.\n"
"\n"
"Completely analogously, setresgid() sets the real GID, effective GID,\n"
"and saved set-group-ID of the calling process (and always modifies\n"
"the filesystem GID to be the same as the effective GID), with the\n"
"same restrictions for unprivileged processes.\n"
"\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/setresuid.2.html\n"
"\n"
"\n"
;

const char* g_signalfd_docstr = 
"\n"
"signalfd() creates a file descriptor that can be used to accept\n"
"signals targeted at the caller.  This provides an alternative to the\n"
"use of a signal handler or sigwaitinfo(2), and has the advantage that\n"
"the file descriptor may be monitored by select(2), poll(2), and\n"
"epoll(7).\n"
"\n"
"The mask argument specifies the set of signals that the caller wishes\n"
"to accept via the file descriptor.  This argument is a signal set\n"
"whose contents can be initialized using the macros described in\n"
"sigsetops(3).  Normally, the set of signals to be received via the\n"
"file descriptor should be blocked using sigprocmask(2), to prevent\n"
"the signals being handled according to their default dispositions.\n"
"It is not possible to receive SIGKILL or SIGSTOP signals via a\n"
"signalfd file descriptor; these signals are silently ignored if\n"
"specified in mask.\n"
"\n"
"If the fd argument is -1, then the call creates a new file descriptor\n"
"and associates the signal set specified in mask with that file\n"
"descriptor.  If fd is not -1, then it must specify a valid existing\n"
"signalfd file descriptor, and mask is used to replace the signal set\n"
"associated with that file descriptor.\n"
"\n"
"Starting with Linux 2.6.27, the following values may be bitwise ORed\n"
"in flags to change the behavior of signalfd():\n"
"\n"
"SFD_NONBLOCK  Set the O_NONBLOCK file status flag on the open file\n"
"              description (see open(2)) referred to by the new file\n"
"              descriptor.  Using this flag saves extra calls to\n"
"              fcntl(2) to achieve the same result.\n"
"\n"
"SFD_CLOEXEC   Set the close-on-exec (FD_CLOEXEC) flag on the new file\n"
"              descriptor.  See the description of the O_CLOEXEC flag\n"
"              in open(2) for reasons why this may be useful.\n"
"\n"
"In Linux up to version 2.6.26, the flags argument is unused, and must\n"
"be specified as zero.\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/signalfd.2.html\n"
"\n"
;

const char* g_signalfd_read_docstr = 
"\n"
"If one or more of the signals specified in mask is pending for\n"
"the process, then the buffer supplied to read(2) is used to\n"
"return one or more signalfd_siginfo structures (see below)\n"
"that describe the signals.  The read(2) returns information\n"
"for as many signals as are pending and will fit in the\n"
"supplied buffer.  The buffer must be at least sizeof(struct\n"
"signalfd_siginfo) bytes.  The return value of the read(2) is\n"
"the total number of bytes read.\n"
"\n"
"As a consequence of the read(2), the signals are consumed, so\n"
"that they are no longer pending for the process (i.e., will\n"
"not be caught by signal handlers, and cannot be accepted using\n"
"sigwaitinfo(2)).\n"
"\n"
"If none of the signals in mask is pending for the process,\n"
"then the read(2) either blocks until one of the signals in\n"
"mask is generated for the process, or fails with the error\n"
"EAGAIN if the file descriptor has been made nonblocking.\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/signalfd.2.html\n"
"\n"
;

const char* g_sigprocmask_docstr = 
"\n"
"sigprocmask() is used to fetch and/or change the signal mask of the\n"
"calling thread.  The signal mask is the set of signals whose delivery\n"
"is currently blocked for the caller (see also signal(7) for more\n"
"details).\n"
"\n"
"The behavior of the call is dependent on the value of how, as\n"
"follows.\n"
"\n"
"SIG_BLOCK\n"
"      The set of blocked signals is the union of the current set and\n"
"      the set argument.\n"
"\n"
"SIG_UNBLOCK\n"
"      The signals in set are removed from the current set of blocked\n"
"      signals.  It is permissible to attempt to unblock a signal\n"
"      which is not blocked.\n"
"\n"
"SIG_SETMASK\n"
"      The set of blocked signals is set to the argument set.\n"
"\n"
"If oldset is non-NULL, the previous value of the signal mask is\n"
"stored in oldset.\n"
"\n"
"If set is NULL, then the signal mask is unchanged (i.e., how is\n"
"ignored), but the current value of the signal mask is nevertheless\n"
"returned in oldset (if it is not NULL).\n"
"\n"
"A set of functions for modifying and inspecting variables of type\n"
"sigset_t (\"signal sets\") is described in sigsetops(3).\n"
"\n"
"The use of sigprocmask() is unspecified in a multithreaded process;\n"
"see pthread_sigmask(3).\n"
"\n"
;

const char* g_unshare_docstr = 
"\n"
"unshare() allows a process (or thread) to disassociate parts of its\n"
"execution context that are currently being shared with other\n"
"processes (or threads).  Part of the execution context, such as the\n"
"mount namespace, is shared implicitly when a new process is created\n"
"using fork(2) or vfork(2), while other parts, such as virtual memory,\n"
"may be shared by explicit request when creating a process or thread\n"
"using clone(2).\n"
"\n"
"The main use of unshare() is to allow a process to control its shared\n"
"execution context without creating a new process.\n"
"\n"
"The flags argument is a bit mask that specifies which parts of the\n"
"execution context should be unshared.  This argument is specified by\n"
"ORing together zero or more of the following constants:\n"
"\n"
"\n"
"Text from the linux manpage project:\n"
"https://www.man7.org/linux/man-pages/man2/unshare.2.html\n"
"\n"
;

